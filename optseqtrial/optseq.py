# AUTOGENERATED! DO NOT EDIT! File to edit: 07optseq.ipynb (unless otherwise specified).

__all__ = ['folder', 'plot_optseq', 'Parameters', 'Mode', 'Activity', 'Resource', 'Temporal', 'State', 'Model',
           'make_gannt', 'make_resource_graph', 'ex1', 'ex2', 'ex3', 'ex4', 'ex5', 'ex6', 'ex7', 'ex8', 'ex9', 'ex10',
           'ex11', 'ex12', 'ex13', 'ex14', 'ex15', 'ex16', 'convert', 'optimize_optseq', 'make_result_df']

# Cell
import sys
import re
import copy
import platform
import string
_trans = str.maketrans("-+*/'(){}^=<>$ #?,¥", "_"*19) #文字列変換用
import pandas as pd
import ast
import pickle
import numpy as np

import base64
from io import BytesIO

import plotly.graph_objs as go
import plotly

from collections import Counter
import plotly.figure_factory as ff
from plotly.subplots import make_subplots
import datetime as dt
from IPython.display import Image, YouTubeVideo
folder = "../data/optseq/"

# Cell
def plot_optseq(file_name: str = "optseq_output.txt" ):
    with open(file_name) as f:
        out = f.readlines()
    x, y = [],[]
    for l in out[9:]:
        sep = re.split("[=()/]", l)
        if sep[0] != 'objective value ':
            break
        val, cpu = map(float, [ sep[1], sep[3]] )
        x.append(cpu)
        y.append(val)
    fig = go.Figure()
    fig.add_trace(go.Scatter(
            x = x,
            y = y,
            mode='markers+lines',
            name= "value",
            marker=dict(
                size=10,
                color= "black")
    ))
    fig.update_layout(title = "OptSeq performance",
                   xaxis_title='CPU time',
                   yaxis_title='Value')
    return fig

# Cell
class Parameters():
    """
    OptSeq parameter class to control the operation of OptSeq.

    - param  TimeLimit: Limits the total time expended (in seconds). Positive integer. Default=600.

    - param  OutputFlag: Controls the output log. Boolean. Default=False (0).

    - param  RandomSeed: Sets the random seed number. Integer. Default=1.

    - param  ReportInterval: Controls the frequency at which log lines are printed (iteration number). Default=1073741823.

    - param  Backtruck: Controls the maximum backtrucks. Default=1000.

    - param  MaxIteration: Sets the maximum numbers of iterations. Default=1073741823.

    - param  Initial: =True if the user wants to set an initial activity list. Default = False.
            Note that the file name of the activity list must be "optseq_best_act_data.txt."

    - param  Tenure: Controls a parameter of tabu search (initial tabu tenure). Default=0.

    - param  Neighborhood: Controls a parameter of tabu search (neighborhood size). Default=20.

    - param  Makespan: Sets the objective function.
            Makespan is True if the objective is to minimize the makespan (maximum completion time),
            is False otherwise, i.e., to minimize the total weighted tardiness of activities.
            Default=False.
    """

    def __init__(self):
        self.TimeLimit = 600
        self.OutputFlag = 0  # off
        self.RandomSeed = 1
        self.ReportInterval = 1073741823
        self.Backtruck = 1000
        self.MaxIteration = 1073741823
        self.Initial = False
        self.Tenure = 1
        self.Neighborhood = 20
        self.Makespan = False

# Cell
class Mode():
    """
    OptSeq mode class.

        - Arguments:
            - name: Name of mode (sub-activity).
                    Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
                    Also you cannot use "dummy" for the name of a mode.
                    - duration(optional): Processing time of mode. Default=0.

        - Attbibutes:
            - requirement: Dictionary that maps a pair of resource name and resource type (rtype) to requirement dictionary.
                    Requirement dictionary maps intervals (pairs of start time and finish time) to amounts of requirement.
                    Resource type (rtype) is None (standard resource type), "break" or "max."
            - breakable: Dictionary that maps breakable intervals to maximum brek times.
            - paralel:  Dictionary that maps parallelable intervals to maximum parallel numbers.
            - state: Dictionary that maps states to the tuples of values.
     """

    def __init__(self, name="", duration=0):

        if name == "dummy":
            print("source and sink cannnot be used as an activity name")
            raise NameError
        self.name = str(name).translate(_trans)
        self.duration = duration
        self.requirement = {}
        self.breakable = {}
        self.parallel = {}
        self.state = {}

    def __str__(self):
        ret = [" duration {0} ".format(self.duration)]

        if self.requirement:
            for (r, rtype) in self.requirement:
                for (interval, cap) in self.requirement[(r, rtype)].items():
                    (s, t) = interval
                    if rtype == "max":
                        ret.append(
                            " {0} max interval {1} {2} requirement {3} ".format(r, s, t, cap))
                    elif rtype == "break":
                        ret.append(
                            " {0} interval break {1} {2} requirement {3} ".format(r, s, t, cap))
                    elif rtype == None:
                        ret.append(
                            " {0} interval {1} {2} requirement {3} ".format(r, s, t, cap))
                    else:
                        print("resource type error")
                        raise TypeError

        # break
        if self.breakable:
            for (interval, cap) in self.breakable.items():
                (s, t) = interval
                if cap == "inf":
                    ret.append(" break interval {0} {1} ".format(s, t))
                else:
                    ret.append(
                        " break interval {0} {1} max {2} ".format(s, t, cap))

        # parallel
        if self.parallel:
            for (interval, cap) in self.parallel.items():
                (s, t) = interval
                if cap == "inf":
                    ret.append(" parallel interval {0} {1} ".format(s, t))
                else:
                    ret.append(
                        " parallel interval {0} {1} max {2} ".format(s, t, cap))

        # state
        if self.state:
            for s in self.state:
                for (f, t) in self.state[s]:
                    ret.append(" {0} from {1} to {2} ".format(s, f, t))

        return " \n".join(ret)

    def addState(self, state, fromValue=0, toValue=0):
        """
        Adds a state change information to the mode.

            - Arguments:
                - state: State object to be added to the mode.
                - fromValue: the value from which the state changes by the mode
                - toValue:  the value to which the state changes by the mode

            - Example usage:

            >>> mode.addState(state1,0,1)

            defines that state1 is changed from 0 to 1.

        """
        if type(fromValue) != type(1) or type(toValue) != type(1):
            print(
                "time and value of the state {0} must be integer".format(self.name))
            raise TypeError
        else:
            if state.name not in self.state:
                self.state[state.name] = [(fromValue, toValue)]
            else:
                self.state[state.name].append((fromValue, toValue))

    def addResource(self, resource, requirement=None, rtype=None):
        """
        Adds a resource to the mode.

            - Arguments:
                - resurce: Resource object to be added to the mode.
                - requirement: Dictionary that maps intervals (pairs of start time and finish time) to amounts of requirement.
                               It may be an integer; in this case, requirement is converted into the dictionary {(0,"inf"):requirement}.
                - rtype (optional): Type of resource to be added to the mode.
                None (standard resource type; default), "break" or "max."

            - Example usage:

            >>> mode.addResource(worker,{(0,10):1})

            defines worker resource that uses 1 unit for 10 periods.

            >>> mode.addResource(machine,{(0,"inf"):1},"break")

            defines machine resource that uses 1 unit during break periods.

            >>> mode.addResource(machine,{(0,"inf"):1},"max")

            defines machine resource that uses 1 unit during parallel execution.
        """
        if requirement == None:
            requirement = {}
        if type(requirement) == type(1):
            requirement = {(0, "inf"): requirement}

        if type(resource.name) != type("") or type(requirement) != type({}):
            print("type error in adding a resource {0} to activity".format(
                resource.name, self.name))
            raise TypeError
        elif rtype == None or rtype == "break" or rtype == "max":
            if (resource.name, rtype) not in self.requirement:
                # generate an empty dic.
                self.requirement[(resource.name, rtype)] = {}
            data = copy.deepcopy(self.requirement[(resource.name, rtype)])
            data.update(requirement)
            self.requirement[(resource.name, rtype)] = data
        else:
            print("rtype must be None or break or max")
            raise NameError

    def addBreak(self, start=0, finish=0, maxtime="inf"):
        """
        Sets breakable information to the mode.

            - Arguments:
                - start(optional): Earliest break time. Non-negative integer. Default=0.
                - finish(optional): Latest break time.  Non-negative integer or "inf." Default=0.
                    Interval (start,finish) defines a possible break interval.
                - maxtime(optional): Maximum break time. Non-negative integer or "inf." Default="inf."

            - Example usage:

            >>> mode.addBreak(0,10,1)

            defines a break between (0,10) for one period.
        """
        data = copy.deepcopy(self.breakable)
        data.update({(start, finish): maxtime})
        self.breakable = data

    def addParallel(self, start=1, finish=1, maxparallel="inf"):
        """
        Sets parallel information to the mode.

            - Arguments:
                - start(optional): Smallest job index executable in parallel. Positive integer. Default=1.
                - finish(optional): Largest job index executable in parallel. Positive integer or "inf." Default=1.
                - maxparallel(optional): Maximum job numbers executable in parallel. Non-negative integer or "inf." Default="inf."

            - Example usage:

            >>> mode.addParallel(1,1,2)
        """
        data = copy.deepcopy(self.parallel)
        data.update({(start, finish): maxparallel})
        self.parallel = data

# Cell
class Activity():
    """
    OptSeq activity class.

        You can create an activity object by adding an activity to a model (using Model.addActivity)
        instead of by using an Activity constructor.

        - Arguments:
                - name: Name of activity. Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
                        Also you cannot use "source" and "sink" for the name of an activity.
                - duedate(optional): Duedate of activity. A non-nagative integer or string "inf."
                - backward(optional): True if activity is distached backwardly, False (default) otherwise.
                - weight(optional): Panalty of one unit of tardiness. Positive integer.
                - autoselect(optional): True or False flag that indicates the activity selects the mode automatically or not.
    """

    ID = 0
    def __init__(self, name="", duedate="inf", backward= False, weight=1, autoselect=False):

        if name == "source" or name == "sink":
            print("source and sink cannnot be used as an activity name")
            raise NameError
        if name == "" or name == None:
            name = "__a{0}".format(Activity.ID)
            Activity.ID += 1
        # convert illegal characters into _ (underscore)
        self.name = str(name).translate(_trans)
        self.duedate = duedate
        self.backward = backward  #backward
        self.weight = weight
        self.autoselect = autoselect
        self.modes = []  # list of mode objects
        self.start = 0
        self.completion = 0
        self.execute = {}
        self.selected = None

    def __str__(self):
        ret = ["activity {0}".format(self.name)]
        if self.duedate != "inf":
            if self.backward==True:
                ret.append(" backward duedate {0} ".format(self.duedate))
            else:
                ret.append(" duedate {0} ".format(self.duedate))
            ret.append(" weight {0} ".format(self.weight))
        if len(self.modes) == 1:  # single mode
            # print mode information
            ret.append(" mode {0} ".format(self.modes[0]))
            # ret.append(str(self.modes[0]))
        elif len(self.modes) >= 2:
            if self.autoselect == True:
                ret.append(" autoselect ")
            for m in self.modes:  # multiple modes
                ret.append(" {0} ".format(m.name))  # print mode names
            # ret+="\n"
        else:
            ret.append(" no mode ")
        return " \n".join(ret)

    def addModes(self, *modes):
        """
        Adds a mode or modes to the activity.

            - Arguments:
                - modes: One or more mode objects.

            - Example usage:

            >>> activity.addModes(mode1,mode2)
        """
        for mode in modes:
            self.modes.append(mode)

# Cell
class Resource():
    """
    OptSeq resource class.

         - Arguments:
             - name: Name of resource.
                     Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
             - capacity (optional): Capacity dictionary of the renewable (standard) resource.
                         Capacity dictionary maps intervals (pairs of start time and finish time) to amounts of capacity.
                         If it is given by a positive integer, it is converted into the dictionay {(0,"inf"):capacity}.
             - rhs (optional): Right-hand-side constant of nonrenewable resource constraint.
             - direction (optional): Rirection (or sense) of nonrenewable resource constraint; "<=" (default) or ">=".
                     - weight (optional): Weight of nonrenewable resource to compute the penalty for violating the constraint. Non-negative integer or "inf" (default).

         - Attbibutes:
             - capacity: Capacity dictionary of the renewable (standard) resource.
             - rhs: Right-hand-side constant of nonrenewable resource constraint.
             - direction: Rirection (or sense) of nonrenewable resource constraint; "<=" (default) or ">=".
             - terms: List of terms in left-hand-side of nonrenewable resource.
                        Each term is a tuple of coeffcient,activity and mode.
             - weight: Weight of nonrenewable resource to compute the penalty for violating the constraint. Non-negative integer or "inf" (default).

     """
    ID = 0

    def __init__(self, name="", capacity=None, rhs=0, direction="<=", weight="inf"):
        if capacity == None:
            capacity = {}
        if name == "" or name == None:
            name = "__r{0}".format(Resource.ID)
            Resource.ID += 1
        # convert illegal characters into _ (underscore)
        self.name = str(name).translate(_trans)

        if type(capacity) == type(1):
            capacity = {(0, "inf"): capacity}

        self.capacity = capacity
        self.rhs = rhs
        self.direction = direction
        self.terms = []
        self.weight = weight
        self.residual = {}

    def __str__(self):
        ret = []
        if self.capacity:
            ret.append("resource {0} ".format(self.name))
            capList = []
            for (interval, cap) in self.capacity.items():
                (s, t) = interval
                capList.append((s, t, cap))
            #capList.sort()
            for (s, t, cap) in capList:
                ret.append(
                    " interval {0} {1} capacity {2} ".format(s, t, cap))
            # ret.append("\n")
        return " \n".join(ret)

    def addCapacity(self, start=0, finish=0, amount=1):
        """
        Adds a capacity to the resource.

            - Arguments:
                - start(optional): Start time. Non-negative integer. Default=0.
                - finish(optional): Finish time. Non-negative integer. Default=0.
                 Interval (start,finish) defines the interval during which the capacity is added.
                - amount(optional): The amount to be added to the capacity. Positive integer. Default=1.

            - Example usage:

            >>> manpower.addCapacity(0,5,2)
        """

        data = copy.deepcopy(self.capacity)
        data.update({(start, finish): amount})
        self.capacity = data

    def printConstraint(self):
        """
            Returns the information of the linear constraint.

            The constraint is expanded and is shown in a readable format.
        """

        f = ["nonrenewable weight {0} ".format(self.weight)]
        if self.direction == ">=" or self.direction == ">":
            for (coeff, var, value) in self.terms:
                f.append(
                    "{0}({1},{2}) ".format(-coeff, var.name, value.name))
            f.append("<={0} \n".format(-self.rhs))
        elif self.direction == "==" or self.direction == "=":
            for (coeff, var, value) in self.terms:
                f.append("{0}({1},{2}) ".format(
                    coeff, var.name, value.name))
            f.append("<={0} \n".format(self.rhs))
            f.append("nonrenewable weight {0} ".format(self.weight))
            for (coeff, var, value) in self.terms:
                f.append(
                    "{0}({1},{2}) ".format(-coeff, var.name, value.name))
            f.append("<={0} \n".format(-self.rhs))
        else:
            for (coeff, var, value) in self.terms:
                f.append("{0}({1},{2}) ".format(
                    coeff, var.name, value.name))
            f.append("<={0} \n".format(self.rhs))

        return "".join(f)

    def addTerms(self, coeffs=None, vars=None, values=None):
        """
        Add new terms into left-hand-side of nonrenewable resource constraint.

            - Arguments:
                - coeffs: Coefficients for new terms; either a list of coefficients or a single coefficient.
                The three arguments must have the same size.
                - vars: Activity objects for new terms; either a list of activity objects or a single activity object.
                The three arguments must have the same size.
                - values: Mode objects for new terms; either a list of mode objects or a single mode object.
                The three arguments must have the same size.

            - Example usage:

            >>> budget.addTerms(1,act,express)

            adds one unit of nonrenewable resource (budget) if activity "act" is executed in mode "express."

        """

        # need a check whether coeffs is numeric ...
        if type(coeffs) != type([]):
            self.terms.append((coeffs, vars, values))
        elif type(coeffs) != type([]) or type(vars) != type([]) or type(values) != type([]):
            print("coeffs, vars, values must be lists")
            raise TypeError
        elif len(coeffs) != len(vars) or len(coeffs) != len(values) or len(values) != len(vars):
            print("length of coeffs, vars, values must be identical")
            raise TypeError
        else:
            for i in range(len(coeffs)):
                self.terms.append((coeffs[i], vars[i], values[i]))

    def setRhs(self, rhs=0):
        """
        Sets the right-hand-side of linear constraint.

            - Argument:
                - rhs: Right-hand-side of linear constraint.

            - Example usage:

            >>> L.setRhs(10)

        """
        self.rhs = rhs

    def setDirection(self, direction="<="):
        if direction in ["<=", ">=", "="]:
            self.direction = direction
        else:
            print(
                "direction setting error; direction should be one of '<=' or '>=' or '='")
            raise NameError

# Cell
class Temporal():
    """
    OptSeq temporal class.

    A temporal constraint has the following form::

        predecessor's completion (start) time +delay <=
                        successor's start (completion) time.

    Parameter "delay" can be negative.

        - Arguments:
            - pred: Predecessor (an activity object) or string "source."
                    Here, "source" specifies a dummy activity that precedes all other activities and starts at time 0.
            - succ: Successor (an activity object) or string "source."
                    Here, "source" specifies a dummy activity that precedes all other activities and starts at time 0.
            - tempType (optional): String that differentiates the temporal type.
                "CS" (default)=Completion-Start, "SS"=Start-Start,
                "SC"= Start-Completion, "CC"=Completion-Completion.
            - delay (optional): Time lag between the completion (start) times of two activities.

        - Attributes:
            - pred: Predecessor (an activity object) or string "source."
            - succ: Successor (an activity object) or string "source."
            - type: String that differentiates the temporal type.
                "CS" (default)=Completion-Start, "SS"=Start-Start,
                "SC"= Start-Completion, "CC"=Completion-Completion.
            - delay: Time lag between the completion (start) times of two activities. default=0.

    """

    def __init__(self, pred, succ, tempType="FS", delay=0):

        self.pred = pred
        self.succ = succ
        self.type = tempType
        self.delay = delay

    def __str__(self):
        if self.pred == "source":
            pred = "source"
        elif self.pred == "sink":
            pred = "sink"
        else:
            pred = str(self.pred.name)

        if self.succ == "source":
            succ = "source"
        elif self.succ == "sink":
            succ = "sink"
        else:
            succ = str(self.succ.name)

        ret = ["temporal {0} {1}".format(pred, succ)]
        ret.append(" type {0} delay {1} ".format(self.type, self.delay))

        return " ".join(ret)

# Cell
class State():
    """
        OptSeq state class.

        You can create a state object by adding a state to a model (using Model.addState)
        instead of by using a State constructor.

            - Arguments:
                - name: Name of state. Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.

    """
    ID = 0

    def __init__(self, name=""):

        if name == "" or name == None:
            name = "__s{0}".format(State.ID)
            State.ID += 1
        # convert illegal characters into _ (underscore)
        self.name = str(name).translate(_trans)

        # dictionary that maps time (non-negative integer) to value (non-negative integer)
        self.Value = {}

    def __str__(self):
        ret = ["state {0} ".format(self.name)]
        for v in self.Value:
            ret.append("time {0} value {1} ".format(v, self.Value[v]))
        return " ".join(ret)

    def addValue(self, time=0, value=0):
        """
        Adds a value to the state
            - Arguments:
                - time: the time at which the state changes.
                - value: the value that the state changbes to

            - Example usage:

            >>> state.addValue(time=5,value=1)
        """
        if type(time) == type(1) and type(value) == type(1):
            self.Value[time] = value
        else:
            print(
                "time and value of the state {0} must be integer".format(self.name))
            raise TypeError

# Cell
class Model(object):
    """
        OptSeq model class.
            - Attributes:
                - activities: Dictionary that maps activity names to activity objects in the model.
                - modes: Dictionary that maps mode names to mode objects in the model.
                - resources:  Dictionary that maps resource names to resource objects in the model.
                - temporals: Dictionary that maps pairs of activity names to temporal constraint objects in the model.
                - Params: Object including all the parameters of the model.

                - act: List of all the activity objects in the model.
                - res: List of all the resource objects in the model.
                - tempo: List of all the tamporal constraint objects in the model.
    """

    def __init__(self, name=""):

        self.name = name
        self.activities = {}  # set of activities maintained by a dictionary
        self.modes = {}  # set of modes maintained by a dictionary
        self.resources = {}  # set of resources maintained by a dictionary
        self.temporals = {}  # set of temporal constraints maintained by a dictionary
        self.states = {}  # set of states maintained by a dictionary

        self.act = []  # list of activity objects
        self.res = []  # list of resource objects
        self.tempo = []  # list of temporal constraint's objects
        self.state = []  # list of state objects

        self.Params = Parameters()  # controal parameters' class
        self.Status = 10      # unsolved

    def __str__(self):
        ret = ["Model:{0}".format(self.name)]
        ret.append("number of activities= {0}".format(len(self.act)))
        ret.append("number of resources= {0}".format(len(self.res)))

        if len(self.res):
            ret.append("\nResource Information")
            for res in self.res:
                ret.append(str(res))
                if len(res.terms) > 0:
                    ret.append(res.printConstraint())

        for a in self.act:
            if len(a.modes) >= 2:
                for m in a.modes:
                    self.modes[m.name] = m

        if len(self.modes):
            ret.append("\nMode Information")
            for i in self.modes:
                # ret.append("{0}\n{1}".format(i,self.modes[i]))
                ret.append(str(i))
                ret.append(str(self.modes[i]))

        if len(self.act):
            ret.append("\nActivity Information")
            for act in self.act:
                ret.append(str(act))

        if len(self.tempo):
            ret.append("\nTemporal Constraint Information")
            for t in self.tempo:
                ret.append(str(t))

        if len(self.state):
            ret.append("\nState Information")
            for s in self.state:
                ret.append(str(s))

        return "\n".join(ret)

    def addActivity(self, name="", duedate="inf", backward = False, weight=1, autoselect=False):
        """
        Add an activity to the model.

            - Arguments:
                - name: Name for new activity. A string object except "source" and "sink." Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
                - duedate(optional): Duedate of activity. A non-nagative integer or string "inf."
                - backward(optional): True if activity is distached backwardly, False (default) otherwise.
                - weight(optional): Panalty of one unit of tardiness. Positive integer.
                - autoselect(optional): True or False flag that indicates the activity selects the mode automatically or not.

            - Return value: New activity object.

            - Example usage:

            >>> a = model.addActivity("act1")

            >>> a = model.addActivity(name="act1",duedate=20,weight=100)

            >>> a = model.addActivity("act1",20,100)
        """
        activity = Activity(name, duedate, backward, weight, autoselect)
        self.act.append(activity)
        # self.activities[activity.name]=activity
        return activity

    def addResource(self, name="", capacity=None, rhs=0, direction="<=", weight="inf"):
        """
        Add a resource to the model.

            - Arguments:
                - name: Name for new resource. Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
                - capacity (optional): Capacity dictionary of the renewable (standard) resource.
                - Capacity dictionary maps intervals (pairs of start time and finish time) to amounts of capacity.
                - rhs (optional): Right-hand-side constant of nonrenewable resource constraint.
                - direction (optional): Rirection (or sense) of nonrenewable resource constraint; "<=" (default) or ">=" or "=".
                - weight (optional): Weight of resource. Non-negative integer or "inf" (default).

            - Return value: New resource object.

            - Example usage:

            >>> r=model.addResource("res1")

            >>> r=model.addResource("res1", {(0,10):1,(12,100):2} )

            >>> r=model.addResource("res2",rhs=10,direction=">=")

        """
        if capacity == None:
            capacity = {}
        res = Resource(name, capacity, rhs, direction, weight)
        self.res.append(res)
        # self.resources[res.name]=res
        return res

    def addTemporal(self, pred, succ, tempType="CS", delay=0):
        """
        Add a temporal constraint to the model.

        A temporal constraint has the following form::

            predecessor's completion (start) time +delay <=
                            successor's start (completion) time.

        Parameter "delay" can be negative.

            - Arguments:
                - pred: Predecessor (an activity object) or string "source."
                        Here, "source" specifies a dummy activity that precedes all other activities and starts at time 0.
                - succ: Successor (an activity object) or string "source."
                        Here, "source" specifies a dummy activity that precedes all other activities and starts at time 0.
                - tempType (optional): String that differentiates the temporal type.
                    "CS" (default)=Completion-Start, "SS"=Start-Start,
                    "SC"= Start-Completion, "CC"=Completion-Completion.
                - delay (optional): Time lag between the completion (start) times of two activities.

            - Return value: New temporal object.

            - Example usage:

            >>> t=model.addTemporal(act1,act2)

            >>> t=model.addTemporal(act1,act2,type="SS",delay=-10)

            To specify the start time of activity act is exactly 50, we use two temporal constraints:

            >>> t=model.addTemporal("source",act,type="SS",delay=50)

            >>> t=model.addTemporal(act,"source",type="SS",delay=50)
        """
        t = Temporal(pred, succ, tempType, delay)
        self.tempo.append(t)
        # self.temporals[pred.name,succ.name]=None
        return t

    def addState(self, name=""):
        """
        Add a state to the model.

            - Arguments:
                - name: Name for new state. Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.

            - Return value: New state object.

            - Example usage:

            >>> a = model.addState("state1")

        """
        s = State(name)
        self.state.append(s)
        # self.states[name]=s
        return s

    def update(self):
        """
        prepare a string representing the current model in the OptSeq input format
        """
        makespan = self.Params.Makespan

        f = []

        self.resources = {}  # dictionary of resources that maps res-name to res-object
        for r in self.res:
            self.resources[r.name] = r
            f.append(str(r))

        self.states = {}  # dictionary of activities that maps state-name to state-object
        for s in self.state:
            self.states[s.name] = s
            f.append(str(s))

        self.modes = {}  # dictionary of modes that maps mode-name to mode-object
        for a in self.act:
            if len(a.modes) >= 2:
                for m in a.modes:
                    self.modes[m.name] = m

        for m in self.modes:  # print mode information
            f.append("mode {0} ".format(m))
            f.append(str(self.modes[m]))

        self.activities = {}  # dictionary of activities that maps activity-name to activity-object
        for a in self.act:
            self.activities[a.name] = a
            f.append(str(a))

        # dictionary of temporal constraints that maps activity name pair to temporal-object
        self.temporals = {}
        for t in self.tempo:
            if t.pred == "source":
                pred = "source"
            elif t.pred == "sink":
                pred = "sink"
            else:
                pred = t.pred.name

            if t.succ == "source":
                succ = "source"
            elif t.succ == "sink":
                succ = "sink"
            else:
                succ = t.succ.name

            self.temporals[(pred, succ)] = t
            f.append(str(t))

        # non-renewable constraint
        for r in self.res:
            self.resources[r.name] = r
            if len(r.terms) > 0:
                f.append(r.printConstraint())

        if makespan:
            f.append("activity sink duedate 0 \n")
        return " \n".join(f)

    def optimize(self):
        """
        Optimize the model using optseq.exe in the same directory.

            - Example usage:

            >>> model.optimize()
        """
        LOG = self.Params.OutputFlag
        f = self.update()
        f2 = open("optseq_input.txt", "w")
        f2.write(f)
        f2.close()

        import subprocess
        if platform.system() == "Windows":
            cmd = "optseq-win "
        elif platform.system() == "Darwin":
            cmd = "./optseq-mac "
        elif platform.system() == "Linux":
            cmd = "./optseq-linux "
        else:
            print(platform.system(), "may not be supported.")
        cmd +=  "-time "+str(self.Params.TimeLimit) + \
                " -backtrack  "+str(self.Params.Backtruck) +\
                " -iteration  "+str(self.Params.MaxIteration) +\
                " -report     "+str(self.Params.ReportInterval) +\
                " -seed      "+str(self.Params.RandomSeed) +\
                " -tenure    "+str(self.Params.Tenure) + \
                " -neighborhood   " + str(self.Params.Neighborhood)

        if self.Params.Initial:
            cmd += " -initial optseq_best_act_data.txt"
        # print ("cmd=",cmd)
        try:
            if platform.system() == "Windows":
                pipe = subprocess.Popen(cmd.split(
                ), stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
            else:
                pipe = subprocess.Popen(
                    cmd, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)

            print("\n ================ Now solving the problem ================ \n")
        except OSError:
            print("error: could not execute command '%s'" % cmd)
            print("please check that the solver is in the path")
            f2 = open("optseq_error.txt", "w")
            f2.write("error: could not execute command")
            f2.close()
            self.Status = 7  # execution falied
            exit(0)

        out, err = pipe.communicate(f.encode())  # get the result
        # print("out", out)
        # print("error", err)

#         if err != b"":
#             # if int(sys.version_info[0])>=3:
#             #    err = err.decode('utf-8')
#             f2 = open("optseq_error.txt", "w")
#             f2.write("error: could not execute command")
#             f2.close()
#             print("error: could not execute command '%s'" % cmd)
#             print("please check that the solver is in the path")
#             self.Status = 7  # execution falied
#             return

        # for Python 3
        if int(sys.version_info[0]) >= 3:
            out = str(out, encoding='utf-8')

        if LOG:
            print("\noutput:")
            print(out)

        print("\nSolutions:")

        """
        optseq output file
        """
        f3 = open("optseq_output.txt", "w")
        f3.write(out)
        f3.close()

        # OptSeq didn't implenent the return number
        # check the return code
        # self.Status = pipe.returncode
        # if self.Status !=0: #if the return code is not "optimal", then return
        #    print("Status=",self.Status)
        #    print("Output=",out)
        #    return

        # search strings
        infeasible = out.find("no feasible schedule found")
        if infeasible > 0:
            print("infeasible solution")
            self.Status = -1  # infeasible
            return
        self.Status = 0       # optimized
        s0 = "--- best solution ---"
        s1 = "--- tardy activity ---"
        s2 = "--- resource residuals ---"
        s3 = "--- best activity list ---"  # added for optseq 3.0
        s4 = "objective value ="
        pos0 = out.find(s0)+len(s0)  # job data start position
        pos1 = out.find(s1, pos0)  # data end position
        pos2 = out.find(s2, pos1)
        pos3 = out.find(s3, pos2)
        pos4 = out.find(s4, pos3)
        # print("data positions",pos0,pos1,pos2,pos3,pos4)
        data = out[pos0:pos1]
        resdata = out[pos2+len(s2):pos3]
        data = data.splitlines()
        reslines = resdata.splitlines()

        # save the best activity list
        bestactdata = out[pos3+len(s3):pos4]
        f3 = open("optseq_best_act_data.txt", "w")
        f3.write(bestactdata.lstrip())
        f3.close()

        for line in reslines:
            if len(line) <= 1:
                continue
            current = line.split()
            resname = current[0][:-1]
            residual = current[1:]
            count = 0
            resDic = {}  # residual capacity
            while count < len(residual):
                interval = residual[count].split(",")
                int1 = int(interval[0][1:])
                int2 = int(interval[1][:-1])
                count += 1
                num = int(residual[count])
                count += 1
                resDic[(int1, int2)] = num
            # print(resname,residual)
            self.resources[resname].residual = resDic

        # job data conversion
        execute = []
        for i in range(len(data)):
            replaced = data[i].replace(",", " ")
            current = replaced.split()  # split by space
            # print(current)
            if len(current) > 1:
                execute.append(current)
        for line in execute:
            # print("line=",line)
            actname = line[0]
            mode = line[1]
            try:
                start = line[2]
            except:
                print("Problem is infeasible")
                exit(0)

            execute = line[3:-1]  # list for breakable activity
            completion = line[-1]
            print("{0:>10} {1:>5} {2:>5} {3:>5}".format(
                actname, mode, start, completion))
            # print("execute=",execute)
            if actname == "source":
                pass
            elif actname == "sink":
                pass
            else:
                self.activities[actname].start = int(start)
                self.activities[actname].completion = int(completion)
                if mode != "---":
                    self.activities[actname].selected = mode
                else:
                    self.activities[actname].selected = self.activities[actname].modes[0]
                exeDic = {}
                for exe in execute:
                    exedata = exe.split("--")
                    start = exedata[0]
                    completion = exedata[1]
                    idx = completion.find("[")
                    # for parallel execution
                    if idx > 0:
                        parallel = completion[idx+1:-1]
                        completion = completion[:idx]
                        # print(completion,idx,parallel)
                    else:
                        parallel = 1
                    exeDic[(int(start), int(completion))] = parallel
                self.activities[actname].execute = exeDic
        return

    def write(self, filename="optseq_chart.txt"):
        """
        Output the gantt's chart as a text file.

            - Argument:
                - filename: Output file name. Default="optseq_chart.txt."

            - Example usage:

            >>> model.write("sample.txt")

        """
        f = open(filename, "w")

        horizon = 0
        actList = []
        for a in self.activities:
            actList.append(a)
            act = self.activities[a]
            horizon = max(act.completion, horizon)
        # print("planning horizon=",horizon)
        actList.sort()
        title = " activity    mode".center(20)+" duration "

        width = len(str(horizon))  # period width =largest index of time
        for t in range(horizon):
            num = str(t+1)
            title += num.rjust(width)+""
        # print(title)
        f.write(title+"\n")
        f.write("-"*(30+(width+1)*horizon)+"\n")
        for a in actList:  # sorted order
            act = self.activities[a]  # act: activity object
            actstring = act.name.center(10)[:10]
            if len(act.modes) >= 2 and act.selected is not None:
                actstring += str(act.selected).center(10)
                actstring += str(self.modes[act.selected].duration).center(10)
                # print(" executed on resource:")
                # print(self.modes[act.selected].requirement,m1.modes[act.selected].rtype)
            else:
                # print("executed on resource:")
                # print(act.modes[0].requirement,act.modes[0].rtype)
                actstring += str(act.modes[0].name).center(10)[:10]
                actstring += str(act.modes[0].duration).center(10)
            execute = [0 for t in range(horizon)]
            for (s, c) in act.execute:
                para = act.execute[s, c]
                for t in range(s, c):
                    execute[t] = int(para)

            for t in range(horizon):
                if execute[t] >= 2:
                    # for res_name in self.modes[act.selected].requirement:
                        # print(res_name)
                    # print(m1.modes[act.selected].rtype)
                    # print(self.modes[act.selected])
                    actstring += "*"+str(execute[t]).rjust(width-1)
                elif execute[t] == 1:
                    actstring += ""+"="*(width)
                elif t >= act.start and t < act.completion:
                    actstring += ""+"."*(width)
                else:
                    actstring += ""+" "*width
            actstring += ""
            # print(actstring)
            f.write(actstring+"\n")
# print(act.name +"  starts at "+str(act.start)+" and finish at " +str(act.completion))
# print("  and is executed :"+str(act.execute)])

        f.write("-"*(30+(width+1)*horizon)+"\n")
        f.write("resource usage/capacity".center(30)+" \n")
        f.write("-"*(30+(width+1)*horizon)+"\n")
        resList = []
        for r in self.resources:
            resList.append(r)
        resList.sort()
        for r in resList:
            res = self.resources[r]
            if len(res.terms) == 0:  # output residual and capacity
                rstring = res.name.center(30)
                cap = [0 for t in range(horizon)]
                residual = [0 for t in range(horizon)]
                for (s, c) in res.residual:
                    amount = res.residual[(s, c)]
                    if c == "inf":
                        c = horizon
                    s = min(s, horizon)
                    c = min(c, horizon)
                    for t in range(s, c):
                        residual[t] += amount

                for (s, c) in res.capacity:
                    amount = res.capacity[(s, c)]
                    if c == "inf":
                        c = horizon
                    s = min(s, horizon)
                    c = min(c, horizon)
                    for t in range(s, c):
                        cap[t] += amount

                for t in range(horizon):
                    num = str(cap[t]-residual[t])
                    rstring += ""+num.rjust(width)
                f.write(rstring+"\n")

                rstring = str(" ").center(30)

                for t in range(horizon):
                    num = str(cap[t])
                    rstring += ""+num.rjust(width)
                f.write(rstring+"\n")
                f.write("-"*(30+(width+1)*horizon)+"\n")
        f.close()

    def writeExcel(self, filename="optseq_chart.csv", scale=1):
        """
        Output the gantt's chart as a csv file for printing using Excel.

            - Argument:
                - filename: Output file name. Default="optseq_chart.csv."

            - Example usage:

            >>> model.writeExcel("sample.csv")

        """
        f = open(filename, "w")
        horizon = 0
        actList = []
        for a in self.activities:
            actList.append(a)
            act = self.activities[a]
            horizon = max(act.completion, horizon)
        # print("planning horizon=",horizon)
        if scale <= 0:
            print("optseq write scale error")
            exit(0)
        original_horizon = horizon
        horizon = int(horizon/scale)+1
        actList.sort()
        title = " activity ,   mode,".center(20)+" duration,"
        width = len(str(horizon))  # period width =largest index of time
        for t in range(horizon):
            num = str(t+1)
            title += num.rjust(width)+","
        f.write(title+"\n")
        for a in actList:  # sorted order
            act = self.activities[a]  # act: activity object
            actstring = act.name.center(10)[:10]+","
            if len(act.modes) >= 2:
                actstring += str(act.selected).center(10)+","
                actstring += str(self.modes[act.selected].duration).center(10)+","
            else:
                actstring += str(act.modes[0].name).center(10)[:10]+","
                actstring += str(act.modes[0].duration).center(10)+","
            execute = [0 for t in range(horizon)]
            for (s, c) in act.execute:
                para = act.execute[s, c]
                for t in range(s, c):
                    t2 = int(t/scale)
                    execute[t2] = int(para)
            for t in range(horizon):
                if execute[t] >= 2:
                    actstring += "*"+str(execute[t]).rjust(width-1)+","
                elif execute[t] == 1:
                    actstring += ""+"="*(width)+","
                elif t >= int(act.start/scale) and t < int(act.completion/scale):
                    actstring += ""+"."*(width)+","
                else:
                    actstring += ""+" "*width+","
            f.write(actstring+"\n")
        resList = []
        for r in self.resources:
            resList.append(r)
        resList.sort()

        for r in resList:
            res = self.resources[r]
            if len(res.terms) == 0:  # output residual and capacity
                rstring = res.name.center(30)+", , ,"
                cap = [0 for t in range(horizon)]
                residual = [0 for t in range(horizon)]
                for (s, c) in res.residual:
                    amount = res.residual[(s, c)]
                    if c == "inf":
                        c = horizon
                    s = min(s, original_horizon)
                    c = min(c, original_horizon)
                    s2 = int(s/scale)
                    c2 = int(c/scale)
                    for t in range(s2, c2):
                        residual[t] += amount

                for (s, c) in res.capacity:
                    amount = res.capacity[(s, c)]
                    if c == "inf":
                        c = horizon
                    s = min(s, original_horizon)
                    c = min(c, original_horizon)
                    s2 = int(s/scale)
                    c2 = int(c/scale)
                    for t in range(s2, c2):
                        cap[t] += amount

                for t in range(horizon):
                    # num=str(cap[t]-residual[t])
                    rstring += str(residual[t]) + ","
                f.write(rstring+"\n")

                # rstring= str(" ").center(30)+", , ,"
                #
                # for t in range(horizon):
                #    num=str(cap[t])
                #    rstring+=""+num.rjust(width) +","
                # f.write(rstring+"\n")
        f.close()

# Cell
def make_gannt(model, start="2019/1/1", period="days"):
    """
    ガントチャートを生成する関数
    """
    start = pd.to_datetime(start)

    def time_convert_long(periods):
        if period =="days":
            time_ = start + dt.timedelta(days=float(periods))
        elif period == "hours":
            time_ = start + dt.timedelta(hours=float(periods))
        elif period == "minutes":
            time_ = start + dt.timedelta(minutes=float(periods))
        elif period == "seconds":
            time_ = start + dt.timedelta(seconds=float(periods))
        else:
            raise TypeError("pariod must be 'days' or 'seconds' or minutes' or 'days'")
        return time_.strftime("%y-%m-%d %H:%M:%S")

    L = []
    for i in model.activities:
        a = model.activities[i]
        res = None
        for r in a.modes[0].requirement:  # key
            res = r[0]
            break
        #print(a.name, a.start, a.completion,res)
        st = time_convert_long(a.start)
        fi = time_convert_long(a.completion)

        L.append(dict(Task=a.name, Start=st, Finish=fi))

    # 可視化するデータと色の情報をplotly.figure_factory.create_gantt()に渡す
    fig = ff.create_gantt(L,  index_col=None, title="Task View",
                          show_colorbar=False, showgrid_x=True, showgrid_y=True, group_tasks=False)
    return fig

# Cell
def make_resource_graph(model):
    """
    資源の使用量と残差（容量-使用量）を図示する関数
    """
    horizon = 0
    for a in model.act:
        horizon = max(a.completion, horizon)
    #print("planning horizon=",horizon)

    count = 0
    for res in model.res:
        if len(res.terms) == 0:  # renwable resource
            count += 1
            # print(count)
            cap = [0 for t in range(horizon)]
            residual = [0 for t in range(horizon)]
            usage = [0 for t in range(horizon)]
            for (s, c) in res.residual:
                amount = res.residual[(s, c)]
                if c == "inf":
                    c = horizon
                s = min(s, horizon)
                c = min(c, horizon)
                for t in range(s, c):
                    residual[t] += amount

            for (s, c) in res.capacity:
                amount = res.capacity[(s, c)]
                if c == "inf":
                    c = horizon
                s = min(s, horizon)
                c = min(c, horizon)
                for t in range(s, c):
                    cap[t] += amount

            for t in range(horizon):
                usage[t] = cap[t]-residual[t]
    if count >= 1:
        fig = make_subplots(rows=len(model.res), cols=1,
                            subplot_titles=[r.name for r in model.res])

        x = list(range(horizon))
        for i, res in enumerate(model.res):
            fig.add_trace(
                go.Bar(name='Usage', x=x, y=usage, marker_color='crimson'),
                row=i+1, col=1
            )
            fig.add_trace(
                go.Bar(name='Residual', x=x, y=residual,
                       marker_color='lightslategrey'),
                row=i+1, col=1
            )
        fig.update_layout(
            barmode='stack', title_text=f"Capacity/Usage", showlegend=False)
    else:
        fig = {}
    return fig

# Cell
def ex1():
    """
    Example 1
    PERT
    file name: Example1.py
    Copyright Log Opt Co., Ltd.

    Consider a 5-activity problem with precedence constraints between the activities.
    Such a problem is called PERT (Program Evaluation and Review Technique).
    The processing times (durations) of the activities are kept in the dictionary
     duration ={1:13, 2:25, 3:15, 4:27, 5:22 }.
    Precedence constraints are given by:
     Activity 1 -> Activity 3; Activity 2 -> Activity 4;
     Activity 3 -> Activity 4; and Activity 3 -> Activity 5.
    The objective is to find the maximum completion time (makespan) for all 5 activities.
    """

    m1 = Model()
    duration = {1: 13, 2: 25, 3: 15, 4: 27, 5: 22}
    act = {}
    mode = {}
    for i in duration:
        act[i] = m1.addActivity("Act[{0}]".format(i))
        mode[i] = Mode("Mode[{0}]".format(i), duration[i])
        act[i].addModes(mode[i])

    # temporal (precedense) constraints
    m1.addTemporal(act[1], act[3])
    m1.addTemporal(act[2], act[4])
    m1.addTemporal(act[2], act[5])
    m1.addTemporal(act[3], act[4])

    m1.Params.TimeLimit = 1
    m1.Params.Makespan = True
    return m1

# Cell
def ex2():
    """
    Example 2
    PERT with resource constraint
    file name: Example2.py
    Copyright Log Opt Co., Ltd.

    Consider a 5-activity problem with precedence constraints between the activities.
    The processing times (durations) of the activities are kept in the dictionary
     duration ={1:13, 2:25, 3:15, 4:27, 5:22 }.
    Precedence constraints are given by:
     Activity 1 -> Activity 3; Activity 2 -> Activity 4;
     Activity 3 -> Activity 4; and Activity 3 -> Activity 5.
    Each activity requires one unit of worker resource whose capacity (maximum amount of availability for each time period) is 1.
    The objective is to find the maximum completion time (makespan) for all 5 activities
    """
    m1=Model()
    duration ={1:13, 2:25, 3:15, 4:27, 5:22 }
    #res=m1.addResource("worker",capacity={(0,"inf"):1})
    res=m1.addResource("worker",capacity=1)

    act={}
    mode={}
    for i in duration:
        act[i]=m1.addActivity("Act[{0}]".format(i))
        mode[i]=Mode("Mode[{0}]".format(i),duration[i])
        mode[i].addResource(res,requirement=1)
        act[i].addModes(mode[i])

    #temporal (precedense) constraints
    m1.addTemporal(act[1],act[3])
    m1.addTemporal(act[2],act[4])
    m1.addTemporal(act[2],act[5])
    m1.addTemporal(act[3],act[4])

    ###作業1の開始時刻を計画期間開始時刻の10分後に固定する制約
    #m1.addTemporal('source',act[1],'SS',10)
    #m1.addTemporal(act[1],'source','SS',-10)

    ###作業2は作業1終了5分～10分の間に開始しなければならないことを表す制約
    #m1.addTemporal(act[1],act[2],'CS',5)
    #m1.addTemporal(act[2],act[1],'SC',-10)

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=True
    return m1

# Cell
def ex3():
    """
    Example 3
    Parallel Shop Problem
    file name: Example3.py
    Copyright Log Opt Co., Ltd.

    Consider a 10-activity problem in which each activity is processed on three identical parallel machines.
    The processing times (durations) of the activities are kept in the dictionary
     duration ={1:3, 2:2, 3:2, 4:2, 5:4, 6:4, 7:4, 8:4, 9:11, 10:2 }.
    Precedence constraints are given by:
     Activity 1 -> Activity 9;
     Activities 5,6,7,8 are processed after Activity 4 and before Activity 10.
    The objective is to find the maximum completion time (makespan).
    """

    m1=Model()
    duration ={1:3, 2:2, 3:2, 4:2, 5:4, 6:4, 7:4, 8:4, 9:11, 10:2 }
    res=m1.addResource("worker",capacity={(0,"inf"):3})
    act={}
    mode={}
    for i in duration:
        act[i]=m1.addActivity("Act[{0}]".format(i))
        mode[i]=Mode("Mode[{0}]".format(i),duration[i])
        mode[i].addResource(res,{(0,"inf"):1})
        act[i].addModes(mode[i])

    #temporal (precedense) constraints
    m1.addTemporal(act[1],act[9])
    for i in range(5,9):
        m1.addTemporal(act[4],act[i])
        m1.addTemporal(act[i],act[10])

    m1.Params.TimeLimit=1
    m1.Params.Makespan=True
    m1.Params.OutputFlag=True
    return m1

# Cell
def ex4():
    """
    Example 4
    Parallel Shop Problem using Modes
    file name: Example4.py
    Copyright Log Opt Co., Ltd.

    Consider a 10-activity problem in which each activity is processed on three identical parallel machines.
    The processing times (durations) of the activities are kept in the dictionary
     duration ={1:3, 2:2, 3:2, 4:2, 5:4, 6:4, 7:4, 8:4, 9:11, 10:2 }.
    Precedence constraints are given by:
     Activity 1 -> Activity 9;
     Activities 5,6,7,8 are processed after Activity 4 and before Activity 10.
    Activity 1 can be processed in one of the following three modes:
     Mode 1 with duration 3 that requires 1 unit of worker resource,
     Mode 2 with duration 2 that requires 2 units of worker resource, and
     Mode 3 with duration 1 that requires 3 units of worker resource.
    The objective is to find the maximum completion time (makespan).
    """

    m1=Model()
    duration ={1:3, 2:2, 3:2, 4:2, 5:4, 6:4, 7:4, 8:4, 9:11, 10:2 }
    res=m1.addResource("worker",capacity=3)
    act={}
    mode={}

    for i in duration:
        act[i]=m1.addActivity("Act[{0}]".format(i))
        if i==1:
            mode[1,1]=Mode("Mode[1_1]",3)
            mode[1,1].addResource(res,1)
            mode[1,2]=Mode("Mode[1_2]",2)
            mode[1,2].addResource(res,2)
            mode[1,3]=Mode("Mode[1_3]",1)
            mode[1,3].addResource(res,3)
            act[i].addModes(mode[1,1],mode[1,2],mode[1,3])
        else:
            mode[i]=Mode("Mode[{0}]".format(i),duration[i])
            mode[i].addResource(res,1)
            act[i].addModes(mode[i])
    #temporal (precedense) constraints
    m1.addTemporal(act[1],act[9])
    for i in range(5,9):
        m1.addTemporal(act[4],act[i])
        m1.addTemporal(act[i],act[10])

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=True
    return m1

# Cell
def ex5():
    """
    Example 5
    Resource Constrained Scheduling
    file name: Example5.py
    Copyright Log Opt Co., Ltd.

    Consider a 4-activity problem with a resource whose capacity is 2 units on day 1, 2, 4, 5, 6, and 1 unit on day 3.
    The processing times (durations) of the activities are kept in the dictionary
     duration ={1:1,2:3,3:2,4:2}.
    Precedence constraints are give by:
     Activity 1 -> Activity 2;
     Activity 1 -> Activity 3;
     Activity 2 -> Activity 4.
    Activity 1 requires 2 units of resource the first day.
    Activity 2 requires 2 units of resource the first day and 1 unit on other days.
    Activity 3 requires 1 unit of resource all the days.
    Activity 4 requires 1 unit of the resource the first day and 2 units on the second day.
    The objective is to find the maximum completion time (makespan).
    """

    m1=Model()
    duration ={1:1,2:3,3:2,4:2}
    req={}
    req[1]={(0,1):2 }
    req[2]={(0,1):2 ,(1,3):1}
    req[3]={(0,2):1 }
    req[4]={(0,1):1,(1,2):2 }

    res=m1.addResource("worker")
    res.addCapacity(0,2,2)
    res.addCapacity(2,3,1)
    res.addCapacity(3,"inf",2)

    act={}
    mode={}

    for i in duration:
        act[i]=m1.addActivity("Act[{0}]".format(i))
        mode[i]=Mode("Mode[{0}]".format(i),duration[i])
        mode[i].addResource(res,requirement=req[i])
        act[i].addModes(mode[i])

    #temporal (precedense) constraints
    m1.addTemporal(act[1],act[2])
    m1.addTemporal(act[1],act[3])
    m1.addTemporal(act[2],act[4])

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=True
    return m1

# Cell
def ex6():
    """
    Example 6
    Minimizing the Tardiness
    file name: Example6.py
    Copyright Log Opt Co., Ltd.

    Consider a 4-activity problem with one machine resource.
    The due dates and processing times (durations) of the activities are kept in the dictionaries
     due={1:5,2:9,3:6,4:4} and
     duration={1:1, 2:2, 3:3, 4:4 }, respectively.
    We have to pay tardiness penalty by the amount the completion time of the activity exceeds its due date.
    The objective is to find the schedule that minimizes total tardiness penalty cost.
    """

    m1=Model()
    due={1:5,2:9,3:6,4:4}
    duration={1:1, 2:2, 3:3, 4:4 }

    res=m1.addResource("writer")
    res.addCapacity(0,"inf",1)

    act={}
    mode={}

    for i in duration:
        act[i]=m1.addActivity("Act[{0}]".format(i),duedate=due[i])
        mode[i]=Mode("Mode[{0}]".format(i),duration[i])
        mode[i].addResource(res,{(0,"inf"):1})
        act[i].addModes(mode[i])

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=False
    return m1

# Cell
def ex7():
    """
    Example 7
    CPM(critical path method) -- nonrenewable resource
    file name: Example7.py
    Copyright Log Opt Co., Ltd.

    Consider the same scenario as in Example 1.
    Here, activities have a standard mode and an express mode whose durations are
    durationA = {1:13, 2:25, 3:15, 4:27, 5:22 } and
    durationB = {1:10, 2:20, 3:10, 4:25, 5:20 }, respectively.
    Express modes require additional costs; they can be processed at most 4.
    Find the makespan under the restriction.

    """

    m1=Model()
    Jobs=[1,2,3,4,5]
    durationA = {1:13, 2:25, 3:15, 4:27, 5:22 }
    durationB = {1:10, 2:20, 3:10, 4:25, 5:20 }

    act={}
    mode={}
    for i in Jobs:
        mode[i,1]=Mode("Mode[{0}][1]".format(i),durationA[i])
        mode[i,2]=Mode("Mode[{0}][2]".format(i),durationB[i])
        act[i]=m1.addActivity("Act[{0}] ".format(i))
        act[i].addModes(mode[i,1],mode[i,2])


    res=m1.addResource("money",rhs=5,direction="<=")

    for i in Jobs:
        res.addTerms(1,act[i],mode[i,2])

    #temporal (precedense) constraints
    m1.addTemporal(act[1],act[3])
    m1.addTemporal(act[2],act[4])
    m1.addTemporal(act[2],act[5])
    m1.addTemporal(act[3],act[4])

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=True
    return m1

# Cell
def ex8():
    """
    Example 8
    Temporal Constraints
    file name: Example8.py
    Copyright Log Opt Co., Ltd.

    Consider the same scenario as in Example 1.
    Here, we add an additional temporal constraint; Activity 3 and Activity 5 must be start simultaneously.
    Find the makespan under this new condition.

    """

    m1=Model()
    durationA = {1:13, 2:25, 3:15, 4:27, 5:22 }

    act={}
    mode={}

    for i in durationA:
        act[i]=m1.addActivity("Act[{0}]".format(i))
        mode[i]=Mode("Mode[{0}]".format(i),durationA[i])
        act[i].addModes(mode[i])

    #temporal (precedense) constraints
    m1.addTemporal(act[1],act[3])
    m1.addTemporal(act[2],act[4])
    m1.addTemporal(act[2],act[5])
    m1.addTemporal(act[3],act[4])

    #act[3] and act[5] start at the same time
    m1.addTemporal(act[3],act[5],"SS",0)
    m1.addTemporal(act[5],act[3],"SS",0)

    # act[5] begins at time 50
    m1.addTemporal("source",act[5],"SS",delay=50)
    m1.addTemporal(act[5],"source","SS",delay=-50)

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=True
    return m1

# Cell
def ex9():
    """
    Example 9
    Breakable Activity
    file name: Example9.py
    Copyright Log Opt Co., Ltd.

    Consider the same scenario as in Example 6.
    Here, Activities can interrupt their processing and re-start after one unit of break time.
    Find the optimal schedule (minimum tardiness solution) under this new condition.
    """

    m1=Model()

    due={1:5,2:9,3:6,4:4}
    duration={1:1, 2:2, 3:3, 4:4 }

    res=m1.addResource("writer")
    res.addCapacity(0,3,1)
    res.addCapacity(4,6,1)
    res.addCapacity(7,10,1)
    res.addCapacity(11,"inf",1)

    act={}
    mode={}

    for i in duration:
        act[i]=m1.addActivity("Act[{0}]".format(i),duedate=due[i])
        mode[i]=Mode("Mode[{0}]".format(i),duration[i])
        mode[i].addResource(res,{(0,"inf"):1})
        mode[i].addBreak(0,"inf",1)
        #mode[i].addBreak(0,1,1) #開始後１日までしか中断を入れられない場合にはここを生かす．
        mode[i].addResource(res,{(0,"inf"):1},"break") #break中も資源を使う場合にはここを生かす。
        act[i].addModes(mode[i])

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=False
    return m1

# Cell
def ex10():
    """
    Example 10
    Parallel Execution
    file name: Example10.py
    Copyright Log Opt Co., Ltd.

    Consider the same scenario as in Example 3.
    Here, Activity 1 can be processed in parallel up to 3 units.
    Find the optimal schedule under this new condition.

    """

    m1=Model()
    duration ={1:3, 2:2, 3:2, 4:2, 5:4, 6:4, 7:4, 8:4, 9:11, 10:2 }

    res=m1.addResource("worker")
    res.addCapacity(0,"inf",3)

    act={}
    mode={}

    for i in duration:
        act[i]=m1.addActivity("Act[{0}]".format(i))

        if i==1:
            mode[i]=Mode("Mode[{0}]".format(i),duration[i])
            mode[i].addParallel(1,1,3)
            #mode[i].addResource(res,1)       #並列実行中の資源量が各作業の使用量の総和のときはこちらを生かす
            mode[i].addResource(res,1,'max') #並列実行中で使用する資源量が最大1のときはこちらを生かす
        else:
            mode[i]=Mode("Mode[{0}]".format(i),duration[i])
            mode[i].addResource(res,1)
        act[i].addModes(mode[i])

    #temporal (precedense) constraints
    m1.addTemporal(act[1],act[9])
    for i in range(5,9):
        m1.addTemporal(act[4],act[i])
        m1.addTemporal(act[i],act[10])

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=True
    return m1

# Cell
def ex11():
    """
    A simple test problem for the Resource Constrained Scheduling Solver OptSeq
    file name: Example11.py
    Copyright Log Opt Co., Ltd.

    Consider a small job shop problem consisting of 4 activities and 3 machines.
    Each activity consists of three sub-jobs (operations).
    Operation must be processed in the order of 1,2 and 3 on thecorresponding machines.
    The machines to be processed and the processing time (days) are kept by the dictionary
    JobInfo={   (1,1):(1,7), (1,2):(2,10), (1,3):(3,4),
                (2,1):(3,9), (2,2):(1,5), (2,3):(2,11),
                (3,1):(1,3), (3,2):(3,9), (3,3):(2,12),
                (4,1):(2,6), (4,2):(3,13),(4,3):(1,9)
                }
    that maps a tuple of activity ID and operation ID to a tuple of machine IDand processing time.
    The objective is to minimize the latest completion time of activities (makespan).
    We add the following practical conditions:
    1. Each operation requires the worker resource for the first 2 days.
    The worker resource is available on weekdays only and its capacity(maximum number of operations to be executed in a day) is 2.
    2. Each operation may have a break after 1 day.
    3. Operations on machine 1 can be processed in parallel.
    4. Operations on machine 2 can be processed in an express mode whose processing time is 4 days.
    The express mode is restricted to be at most once in a whole.
    5. On machine 1, operation 2 must be executed just after operation 1.
    """

    m1 = Model()
    # resource declaration
    machine = {}  # define three machines
    for j in range(1, 4):
        machine[j] = m1.addResource(
            "machine[{0}]".format(j), capacity={(0, "inf"): 1})

    # CAP={} #capacity of human resources; two workers are available on weekdays
    # for t in range(9):
    #    CAP[(t*7,t*7+5)]=2
    # manpower=m1.addResource("manpower",capacity=CAP)
    # we may write ...
    manpower = m1.addResource("manpower")
    for t in range(9):
        manpower.addCapacity(t*7, t*7+5, 2)

    # budget constraint
    budget = m1.addResource("budget_constraint", rhs=1)

    # activity declaration (4 activities are processed on three machines)
    # JobInfo containes the info. of operations (activity,1..3):-> machine ID and proc. time
    JobInfo = {(1, 1): (1, 7), (1, 2): (2, 10), (1, 3): (3, 4),
               (2, 1): (3, 9), (2, 2): (1, 5), (2, 3): (2, 11),
               (3, 1): (1, 3), (3, 2): (3, 9), (3, 3): (2, 12),
               (4, 1): (2, 6), (4, 2): (3, 13), (4, 3): (1, 9)
               }
    act = {}
    express = Mode("Express", duration=4)
    express.addResource(machine[2], {(0, "inf"): 1}, "max")
    express.addResource(manpower, {(0, 2): 1})
    express.addBreak(1, 1)
    # express.addParallel(1,1,2)

    mode = {}
    for (i, j) in JobInfo:  # for each job and machine
        act[i, j] = m1.addActivity("Act[{0}][{1}]".format(i, j))
        mode[i, j] = Mode("Mode[{0}][{1}]".format(
            i, j), duration=JobInfo[i, j][1])
        mode[i, j].addResource(machine[JobInfo[i, j][0]], {
                               (0, "inf"): 1}, "max")
        mode[i, j].addResource(manpower, {(0, 2): 1})
        mode[i, j].addBreak(1, 1)
        if JobInfo[i, j][0] == 1:
            mode[i, j].addParallel(1, 1, 2)

        if JobInfo[i, j][0] == 2:
            # activities processed on machine 2 have two modes, Express and Normal.
            act[i, j].addModes(mode[i, j], express)
            # Express mode needs one budget
            budget.addTerms(1, act[i, j], express)
        else:
            act[i, j].addModes(mode[i, j])  # single mode activity
        # print act[i,j]
    # temporal (precedense) constraints
    for i in range(1, 5):
        for j in range(1, 3):
            m1.addTemporal(act[i, j], act[i, j+1])

    # Define that Act[2][2] must be processed just after Act[1][1] on machine 1
    # introduce dummy with duration 0 and can break at time 0
    # it requires machine 1 during the break,
    #  completion of Act[1][1]=start of dummy and completaion of dummy=start of Act[2][2]
    d_act = m1.addActivity("dummy_activity")
    d_mode = Mode("dummy_mode")
    d_mode.addBreak(0, 0)
    d_mode.addResource(machine[1], {(0, 0): 1}, "break")
    d_act.addModes(d_mode)
    m1.addTemporal(act[1, 1], d_act, tempType="CS")
    m1.addTemporal(d_act, act[1, 1], tempType="SC")
    m1.addTemporal(d_act, act[2, 2], tempType="CS")
    m1.addTemporal(act[2, 2], d_act, tempType="SC")

    m1.Params.TimeLimit = 1
    m1.Params.OutputFlag = True
    m1.Params.Makespan = True
    return m1

# Cell
def ex12():
    """
    Example 12
    Example with state
    file name: Example12.py
    Copyright Log Opt Co., Ltd.
    """
    m1 = Model()
    n = 9 #number of activities

    state = m1.addState("state")
    state.addValue( time=0,  value=0 )
    state.addValue( time=7,  value=0 )
    state.addValue( time=14, value=0 )

    mode = Mode('mode', 1)
    mode.addState( state, 0, 1)
    mode.addState( state, 1, 2)
    mode.addState( state, 2, 3)

    act ={}
    for i in range(n):
        act[i] = m1.addActivity(f"act{i}", duedate = i, autoselect= True)
        act[i].addModes(mode)

    m1.Params.TimeLimit = 1
    m1.Params.OutputFlag = True
    m1.Params.Makespan = False
    return m1

# Cell
def ex13():
    """
    順序依存の段取り時間の例題
    """

    m1 = Model()

    duration = {"D": 30, "E": 30, "F": 30}
    setup = {("D", "E"): 10, ("E", "D"): 50, ("E", "F"): 10, ("F", "E"): 10,
             ("start", "D"): 0, ("start", "E"): 10, ("start", "F"): 0,
             ("D", "F"): 0, ("F", "D"): 0}
    s = {"D": 1, "E": 2, "F": 3, "start": 0}

    rs = m1.addResource("line1", 1)

    act = {}
    mode = {}
    for i in duration:
        act[i] = m1.addActivity("Act_{0}".format(i))
        mode[i] = Mode("Mode_{0}".format(i), duration[i])
        mode[i].addResource(rs, {(0, "inf"): 1})
        act[i].addModes(mode[i])

    s1 = m1.addState("Setup_State")
    s1.addValue(time=0, value=s["start"])
    # setup mode
    mode_setup = {}
    for (i, j) in setup:
        mode_setup[i, j] = Mode("Mode_setup_{0}_{1}".format(i, j), setup[i, j])
        mode_setup[i, j].addState(s1, s[i], s[j])
        if setup[i, j] != 0:
            mode_setup[i, j].addResource(rs, {(0, setup[i, j]): 1})

        #print (i,j,s[i],s[j],mode_setup[i,j])

    act_setup = {}
    for k in duration:
        act_setup[k] = m1.addActivity("Setup_{0}".format(k), autoselect=True)
        for (i, j) in setup:
            if k == j:
                act_setup[k].addModes(mode_setup[i, j])

    # temporal (precedense) constraints
    for j in act_setup:
        m1.addTemporal(act_setup[j], act[j], "CS")
        m1.addTemporal(act[j], act_setup[j], "SC")

    # print(m1)
    # m1.Params.Initial="Example13initial.txt"
    m1.Params.TimeLimit = 1
    m1.Params.OutputFlag = True
    m1.Params.Makespan = True
    return m1

# Cell
def ex14():
    """
    タンク（貯蔵資源）を考慮した例題
    """
    m = Model()
    duration = {1: 13, 2: 25}
    act = {}
    mode = {}
    for i in duration:
        act[i] = m.addActivity("Act[{0}]".format(i))
        mode[i] = Mode("Mode[{0}]".format(i), duration[i])
        act[i].addModes(mode[i])

    r1 = m.addResource("Tank1", 1)
    r2 = m.addResource("Tank2", {(0, 10): 1})

    dummy = m.addActivity("actDum")
    modeDum1 = Mode("DumMode1", 0)
    modeDum2 = Mode("DumMode2", 0)
    #modeDum1.addBreak(0, 0, 10)  # infeasible
    modeDum1.addBreak(0,0,30) #feasible
    modeDum1.addResource(r1, 1, rtype="break")
    modeDum2.addBreak(0, 0, "inf")
    modeDum2.addResource(r2, 1, rtype="break")
    dummy.addModes(modeDum1, modeDum2)

    m.addTemporal(act[1], dummy, "SS", 0)
    m.addTemporal(dummy, act[1], "SS", 0)
    m.addTemporal(act[2], dummy, "CC", 0)
    m.addTemporal(dummy, act[2], "CC", 0)

    m.addTemporal(act[1], act[2], "SS", 3)
    # print(m)
    m.Params.TimeLimit = 1
    return m

# Cell
def ex15(fname = "../data/optseq/ft06.txt"):
    """
    ジョブショップスケジューリング問題のベンチマーク問題例
    """
    f = open(fname,"r")
    lines = f.readlines()
    f.close()
    n, m = map(int, lines[0].split())
    print("n,m=", n, m)

    model = Model()
    act, mode, res = {}, {}, {}
    for j in range(m):
        res[j] = model.addResource(f"machine[{j}]",capacity=1)

    # prepare data as dic
    machine, proc_time ={}, {}
    for i in range(n):
        L = list(map(int,lines[i+1].split()))
        for j in range(m):
            machine[i,j] = L[2*j]
            proc_time[i,j] = L[2*j+1]

    for i,j in proc_time:
        act[i,j] = model.addActivity(f"Act[{i}{j}]")
        mode[i,j]=Mode(f"Mode[{i}{j}]", proc_time[i,j])
        mode[i,j].addResource(res[j],1)
        act[i,j].addModes(mode[i,j])

    for i in range(n):
        for j in range(m-1):
            model.addTemporal(act[i,j],act[i,j+1])

    model.Params.TimeLimit=1
    model.Params.Makespan =True
    return model

# Cell
def ex16():
    """
    Example 16
    Minimizing the Tardiness
    file name: Example16.py
    Copyright Log Opt Co., Ltd.

    Consider a 4-activity problem with one machine resource.
    The due dates and processing times (durations) of the activities are kept in the dictionaries
     due={1:15,2:9,3:6,4:4} and
     duration={1:1, 2:2, 3:3, 4:4 }, respectively.
    We have to pay tardiness penalty by the amount the completion time of the activity exceeds its due date.
    The objective is to find the schedule that minimizes total tardiness penalty cost.

    But the activity 1 shoud be dispatched as late as possible!
    """

    m1=Model()
    due={1:15,2:9,3:6,4:4}
    duration={1:1, 2:2, 3:3, 4:4 }

    res=m1.addResource("writer")
    res.addCapacity(0,"inf",1)

    act={}
    mode={}

    for i in duration:
        if i==1:
            act[i]=m1.addActivity("Act[{0}]".format(i), duedate=due[i], backward=True)
        else:
            act[i]=m1.addActivity("Act[{0}]".format(i), duedate=due[i])
        mode[i]=Mode("Mode[{0}]".format(i),duration[i])
        mode[i].addResource(res,{(0,"inf"):1})
        act[i].addModes(mode[i])

    m1.addTemporal(act[4],act[1])

    m1.Params.TimeLimit=1
    m1.Params.OutputFlag=True
    m1.Params.Makespan=False
    return m1

# Cell
def convert(model):
    """
    convert OptSeq model object to dataframes
    """
    def make_df(object_list, att_list):
        dic = {i: [] for i in att_list}
        for a in object_list:
            for i in dic:
                dic[i].append(a.__getattribute__(i))
        return pd.DataFrame(dic)

    model.update() #情報の更新

    # activity table
    act_df = make_df(model.act, ["name", "duedate", "backward", "weight", "autoselect"])

    # resource table
    att_list = ["name", "capacity"]
    dic = {i: [] for i in att_list}
    for r in model.res:
        if len(r.terms) == 0:
            for i in dic:
                dic[i].append(r.__getattribute__(i))
    res_df = pd.DataFrame(dic)
    # dictionary raises an error in Dash
    res_df = res_df.astype({'capacity': str})

    #res_df = make_df(model.res, ["name", "capacity"])
    # res_df = res_df.astype({'capacity':str}) # dictionary raises an error in Dash

    # mode table
    att_list = ["name", "duration", "breakable", "parallel", "state"]
    dic = {i: [] for i in att_list}
    for a in model.act:
        if len(a.modes) == 1:
            m = a.modes[0]
            for i in dic:
                dic[i].append(m.__getattribute__(i))
    for m in model.modes.values():
        for i in dic:
            dic[i].append(m.__getattribute__(i))
    mode_df = pd.DataFrame(dic)
    # dictionary raises an error in Dash
    mode_df = mode_df.astype(
        {"duration": str, "breakable": str, "parallel": str, "state": str})

    # act-mode table
    dic = {"activity": [], "mode": []}
    for a in model.act:
        if len(a.modes) == 1:
            m = a.modes[0]
            dic["activity"].append(a.name)
            dic["mode"].append(m.name)
        else:
            for m in a.modes:
                dic["activity"].append(a.name)
                dic["mode"].append(m.name)
    act_mode_df = pd.DataFrame(dic)

    # mode-resource table
    att_list = ["mode", "resource", "type", "requirement"]
    dic = {i: [] for i in att_list}
    for a in model.act:
        if len(a.modes) == 1:
            m = a.modes[0]
            for res in m.requirement:
                dic["mode"].append(m.name)
                dic["resource"].append(res[0])
                dic["type"].append(res[1])  # max or break or None
                dic["requirement"].append(str(m.requirement[res]))
    for m in model.modes.values():
        for res in m.requirement:
            dic["mode"].append(m.name)
            dic["resource"].append(res[0])
            dic["type"].append(res[1])  # max or break or None
            dic["requirement"].append(str(m.requirement[res]))
    mode_res_df = pd.DataFrame(dic)

    # temporal table
    att_list = ["pred", "succ", "type", "delay"]
    dic = {i: [] for i in att_list}
    for temp in model.tempo:
        if temp.pred == "source":
            dic["pred"].append("source")
        elif temp.pred == "sink":
            dic["pred"].append("sink")
        else:
            dic["pred"].append(temp.pred.name)
        if temp.succ == "source":
            dic["succ"].append("source")
        elif temp.succ == "sink":
            dic["succ"].append("sink")
        else:
            dic["succ"].append(temp.succ.name)
        dic["type"].append(temp.type)
        dic["delay"].append(temp.delay)
    temp_df = pd.DataFrame(dic)

    # non-renewable resource tables (non_res=nonrenewable resource, non_lhs=nonrenewable left-hand-side)
    att_list = ["name", "rhs", "direction"]
    dic = {i: [] for i in att_list}
    for r in model.res:
        if len(r.terms) > 0:
            for i in dic:
                dic[i].append(r.__getattribute__(i))
    non_res_df = pd.DataFrame(dic)

    # non_res.head()
    att_list = ["res_name", "term", "act_name", "mode_name"]
    dic = {i: [] for i in att_list}
    for r in model.res:
        #print(r.name, r.rhs, r.direction)
        for (i, a, m) in r.terms:
            # print(i, a.name, m.name
            dic["res_name"].append(r.name)
            dic["term"].append(i)
            dic["act_name"].append(a.name)
            dic["mode_name"].append(m.name)
    non_lhs_df = pd.DataFrame(dic)

    #state table
    # state-name, {time:value, ... }
    att_list = ["state_name", "time_value"]
    dic = {i: [] for i in att_list}
    for s in model.state:
        dic["state_name"].append(s.name)
        dic["time_value"].append(str(s.Value))
    state_df = pd.DataFrame(dic)

    return act_df, res_df, mode_df, act_mode_df, mode_res_df, temp_df, non_res_df, non_lhs_df, state_df

# Cell
def optimize_optseq(makespan, cpu, act_df, mode_df, res_df, act_mode_df, mode_res_df, temp_df,
                    non_res_df=None, non_lhs_df=None, state_df=None):
    """
     make a model and optimize using: act_df,res_df,mode_df,act_mode_df,mode_res_df,temp_df,  non_res_df, non_lhs_df, state_df
    """
    model = Model()
    act = {}
    mode = {}
    res = {}

    mode_res_df = mode_res_df.replace({np.nan: None})

    for row in act_df.itertuples():
        # print(*row[1:])
        act[row.name] = model.addActivity(*row[1:])

    for row in res_df.itertuples():
        # print(*row[1:])
        res[row.name] = model.addResource(
            name=row.name, capacity=ast.literal_eval(str(row.capacity)))

    for row in mode_df.itertuples():
        # print(*row[1:])
        mode[row.name] = Mode(*row[1:3])
        # set breakable parallel state
        mode[row.name].breakable = ast.literal_eval(str(row.breakable))
        mode[row.name].parallel = ast.literal_eval(str(row.parallel))
        mode[row.name].state = ast.literal_eval(str(row.state))

    for row in mode_res_df.itertuples():
        mode[row.mode].addResource(res[row.resource], requirement=ast.literal_eval(
            str(row.requirement)), rtype=row.type)

    for row in act_mode_df.itertuples():
        act[row.activity].addModes(mode[row.mode])

    for row in temp_df.itertuples():
        if row.pred == "source":
            pred_ = "source"
        elif row.pred == "sink":
            pred_ = "sink"
        else:
            pred_ = act[row.pred]

        if row.succ == "source":
            succ_ = "source"
        elif row.succ == "sink":
            succ_ = "sink"
        else:
            succ_ = act[row.succ]
        model.addTemporal(pred_, succ_,
                          tempType=row.type, delay=row.delay)

    # non-renewable resource
    if non_res_df is not None:
        non_res_dic = {}
        for row in non_res_df.itertuples():
            non_res_dic[row.name] = model.addResource(
                row.name, rhs=int(row.rhs), direction=row.direction)

        for row in non_lhs_df.itertuples():
            #print(row.res_name, model.resources)
            r = non_res_dic[row.res_name]
            r.addTerms(int(row.term), act[row.act_name], mode[row.mode_name])
        # res.addTerms(1,act[i],mode[i,2])

    # state
    if state_df is not None:
        # s1=m1.addState("Setup_State")
        # s1.addValue(time=0,value=1)
        for row in state_df.itertuples():
            s = model.addState(row.state_name)
            time_value_dic = ast.literal_eval(str(row.time_value))
            for t in time_value_dic:
                v = time_value_dic[t]
                s.addValue(t, v)

    model.Params.TimeLimit = int(cpu)
    model.Params.Makespan = makespan
    model.Params.OutputFlag = True
    model.optimize()

    return model

# Cell
def make_result_df(model):
    """
    最適化した結果を入れたデータフレームを生成する関数
    """
    # make a result data frame
    dic = {i: [] for i in ["name", "start", "completion", "mode"]}
    for a in model.act:
        #st = time_convert_long(a.start)
        #fi = time_convert_long(a.completion)
        dic["name"].append(a.name)
        dic["start"].append(a.start)
        dic["completion"].append(a.completion)
        if type(a.selected) == str:
            dic["mode"].append(a.selected)
        else:
            dic["mode"].append("-")

    df = pd.DataFrame(dic, columns=["name", "start", "completion", "mode"])
    return df

# Cell
# def make_div(id_name, df, column_type):
#     """
#     似たようなレイアウトの一部（表を含む）を何度も書くことを避けるため、Div自体を返す関数を準備する。

#     引数：

#     - id_name: 追加したいテーブルのid名
#     - df: 表に記入したいデータフレーム
#     - column_type: 列のタイプ

#     列のタイプを指定

#      -   numeric: includes both integers and floats
#      -   text: string, sequence of characters
#      -   datetime: string in the form 'YYYY-MM-DD HH:MM:SS.ssssss' or some truncation thereof
#      -   any: any type of data

#      さらにデータ追加のボタンもしくはuploadコンポーネントもつけておく。
#     """
#     return html.Div(
#         children=make_table(id_name, df, column_type))

# Cell
# def make_table(id_name, df, column_type):
#     """
#     標準的なテーブルを返す関数。id名、データフレーム、列のタイプを入力する。
#     """
#     return [dash_table.DataTable(
#         id=id_name,
#         # exportするフォーマットを指定(csv or xlsx)
#         export_format='csv',
#         #columns=[{"name": i, "id": i} for i in df.columns],
#         columns=[{"name": i, "id": i, "type": j}
#                  for (i, j) in zip(df.columns, column_type)],

#         data=df.to_dict('records'),
#         editable=True,
#         # filter_action="native",
#         # dropdown ={},  #ドロップダウンボックス設定用
#         sort_action="native",
#         sort_mode="multi",
#         column_selectable="single",
#         row_selectable="multi",
#         row_deletable=True,
#         selected_columns=[],
#         selected_rows=[],
#         page_action="native",
#         page_current=0,
#         page_size=10,
#         style_header={'backgroundColor': 'rgb(30, 30, 30)'},
#         style_cell={
#                     'backgroundColor': 'rgb(50, 50, 50)',
#                     'color': 'white'},
#     ),
#         html.Div(id=id_name+'-container'),
#         # html.Button('Add Row', id=id_name+'-button', n_clicks=0), #列追加ボタン
#         # uploadコンポーネント
#         dcc.Upload(
#         id=id_name+'-upload',
#         children=html.Div([
#             'Drag and Drop or ',
#             html.A('Select Files')
#         ]),
#         style={
#             'width': '100%', 'height': '60px', 'lineHeight': '60px',
#             'borderWidth': '1px', 'borderStyle': 'dashed',
#             'borderRadius': '5px', 'textAlign': 'center', 'margin': '10px'
#         },
#     ),
#     ]